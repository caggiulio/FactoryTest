{"metadata":{"role":"article","roleHeading":"Article","modules":[{"name":"FactoryKit"}],"title":"SwiftUI"},"variants":[{"paths":["\/documentation\/factorykit\/swiftui"],"traits":[{"interfaceLanguage":"swift"}]}],"kind":"article","sections":[],"seeAlsoSections":[{"generated":true,"identifiers":["doc:\/\/FactoryKit\/documentation\/FactoryKit\/Previews","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Testing","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Contexts","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Debugging","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Chains"],"anchor":"Development-and-Testing","title":"Development and Testing"}],"schemaVersion":{"minor":3,"patch":0,"major":0},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/SwiftUI"},"hierarchy":{"paths":[["doc:\/\/FactoryKit\/documentation\/FactoryKit"]]},"abstract":[{"text":"Defining and using dependencies in SwiftUI.","type":"text"}],"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Factory can make SwiftUI easier to use when we’re using view models or services and those entities depend on internal dependencies. Let’s take a look."}]},{"anchor":"StateObjects","level":2,"type":"heading","text":"StateObjects"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Factory can be used to assign a fully constructed dependency to a "},{"code":"StateObject","type":"codeVoice"},{"type":"text","text":" or "},{"code":"ObservedObject","type":"codeVoice"},{"type":"text","text":"."}]},{"type":"codeListing","code":["\/\/ the view model","class ContentViewModel: ObservableObject {","    @Injected(\\.myService) private var service","    @Published var results: Results","    func load() async {","        results = await service.load()","    }","}","","\/\/ the factory","extension Container {","    var contentViewModel: Factory<ContentViewModel> {","        self { ContentViewModel() }","    }","}","","\/\/ the view","struct ContentView: View {","    @StateObject var viewModel = Container.shared.contentViewModel()","    var body: some View {","        ...","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Keep in mind that if you assign to an ","type":"text"},{"code":"ObservedObject","type":"codeVoice"},{"text":" your Factory is responsible for managing the object’s lifecycle (see the section on Scopes).","type":"text"}]},{"anchor":"InjectedObject","level":2,"type":"heading","text":"InjectedObject"},{"type":"paragraph","inlineContent":[{"text":"Then again, if your view model is coming from Factory, we can bypass the shared container code and just use the ","type":"text"},{"code":"InjectedObject","type":"codeVoice"},{"text":" property wrapper.","type":"text"}]},{"type":"codeListing","code":["\/\/ the view","struct ContentView: View {","    @InjectedObject(\\.contentViewModel) private var viewModel","    var body: some View {","        ...","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"InjectedObject uses ","type":"text"},{"code":"StateObject","type":"codeVoice"},{"text":" under the hood, so ownership is implied.","type":"text"}]},{"anchor":"ViewModel-Dependencies","level":2,"type":"heading","text":"ViewModel Dependencies"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that our view model used the "},{"isActive":true,"type":"reference","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Injected"},{"type":"text","text":" property wrapper to obtain its dependency."}]},{"code":["class ContentViewModel: ObservableObject {","    @Injected(\\.myService) private var service","    ...","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"As such, there’s no particular reason to obtain the view model from Factory since the view model knows what it needs and it’s perfectly capable of managing things for itself."}]},{"code":["struct ContentView: View {","    @StateObject private var viewModel = ContentViewModel()","    var body: some View {","        ...","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"That would be different if, for example, our view model wanted its dependencies passed via an initializer.","type":"text"}]},{"code":["class ContentViewModel: ObservableObject {","    private let service: MyServiceType","    init(service: MyServiceType)","        self.service = service","    }","    ...","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In which case we might indeed want our container to provide a fully initialized object."}]},{"code":["extension Container {","    var contentViewModel: Factory<ContentViewModel> {","        self { ContentViewModel(service: myService()) }","    }","    var myService: Factory<MyServiceType> {","        self { MyService() }","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"And back to ","type":"text"},{"type":"codeVoice","code":"InjectedObject"},{"text":" we go.","type":"text"}]},{"text":"Observation","type":"heading","anchor":"Observation","level":2},{"inlineContent":[{"text":"Apple added support for a new framework to iOS 17–Observation. Observation promises better efficiency and fewer view updates when used across multiple views. So how do we use it?","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Here’s our previous example, updated for Observation."}],"type":"paragraph"},{"code":["@Observable","class ContentViewModel {","    @ObservationIgnored @Injected(\\.myService) private var service","    var results: Results","    func load() async {","        results = await service.load()","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"We replaced the ","type":"text"},{"code":"ObservableObject","type":"codeVoice"},{"text":" protocol conformance with the ","type":"text"},{"code":"@Observable","type":"codeVoice"},{"text":" macro and removed the ","type":"text"},{"code":"@Published","type":"codeVoice"},{"text":" attribute from results.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Note, however, that we needed to add ","type":"text"},{"code":"@ObservationIgnored","type":"codeVoice"},{"text":" to our ","type":"text"},{"code":"Injected","type":"codeVoice"},{"text":" service property wrapper. It’s a private value and doesn’t need to be visible outside of our view model.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Here’s the view."}],"type":"paragraph"},{"type":"codeListing","code":["struct ContentView: View {","    @InjectedObservable(\\.contentViewModel) var viewModel","    var body: some View {","        ...","    }","}"],"syntax":"swift"},{"inlineContent":[{"text":"Instead of ","type":"text"},{"type":"codeVoice","code":"InjectedObject"},{"text":" we use ","type":"text"},{"type":"codeVoice","code":"InjectedObservable"},{"text":", a new property wrapper that understands how to work with the Observable protocol established by Observation.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"InjectedObservable uses "},{"type":"codeVoice","code":"State"},{"type":"text","text":" under the hood and, like "},{"type":"codeVoice","code":"InjectedObject"},{"type":"text","text":", owns the instance in question."}],"type":"paragraph"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"One should also note that InjectedObject “thunks” its parameter and only one instance of the injected view model will be created for the lifetime of the view."}]}],"type":"paragraph"},{"text":"Coping With @MainActor","anchor":"Coping-With-MainActor","type":"heading","level":2},{"inlineContent":[{"text":"One last thing missing from our SwiftUI sample code is @MainActor, that Swift Concurrency attribute used to ensure all view updates occur on the main thread.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Let’s update our view model and see what else needs to change.","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["\/\/ the view model","@MainActor","@Observable","class ContentViewModel {","    @ObservationIgnored @Injected(\\.myService) private var service","    var results: Results","    func load() async {","        results = await service.load()","    }","}","","\/\/ the factory","extension Container {","    @MainActor","    var contentViewModel: Factory<ContentViewModel> {","        self { ContentViewModel() }","    }","}","","\/\/ the view","struct ContentView: View {","    @InjectedObservable(\\.contentViewModel) var viewModel","    var body: some View {","        ...","    }","}"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"As you can see adding "},{"code":"@MainActor","type":"codeVoice"},{"type":"text","text":" to our view model also required us to annotate the Factory accordingly, adding it to both the definition "},{"type":"emphasis","inlineContent":[{"type":"text","text":"and"}]},{"type":"text","text":" to the factory closure."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"While we’d never do it in this case, adding actor isolation to the base factory also means that we’d need to do so again should we ever want to register a new factory."}],"type":"paragraph"},{"type":"codeListing","code":["Container.shared.contentViewModel.register { ","    ContentViewModel()","}",""],"syntax":"swift"}]}],"references":{"doc://FactoryKit/documentation/FactoryKit/Debugging":{"abstract":[{"text":"Additional support for debugging resolution cycles, dependency chains and other issue.","type":"text"}],"role":"article","url":"\/documentation\/factorykit\/debugging","kind":"article","type":"topic","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Debugging","title":"Debugging"},"doc://FactoryKit/documentation/FactoryKit/Testing":{"url":"\/documentation\/factorykit\/testing","abstract":[{"type":"text","text":"Using Factory for Unit and UI Testing."}],"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Testing","role":"article","type":"topic","title":"Testing","kind":"article"},"doc://FactoryKit/documentation/FactoryKit/Chains":{"abstract":[{"type":"text","text":"Detecting and solving Circular Dependency Chains."}],"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Chains","type":"topic","kind":"article","title":"Circular Dependency Chains","url":"\/documentation\/factorykit\/chains","role":"article"},"doc://FactoryKit/documentation/FactoryKit/Previews":{"title":"SwiftUI Previews","kind":"article","role":"article","url":"\/documentation\/factorykit\/previews","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Previews","abstract":[{"text":"Mocking dependencies for SwiftUI Previews.","type":"text"}],"type":"topic"},"doc://FactoryKit/documentation/FactoryKit":{"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit","title":"FactoryKit","type":"topic","url":"\/documentation\/factorykit","kind":"symbol","role":"collection","abstract":[{"type":"text","text":"A modern approach to Container-Based Dependency Injection for Swift and SwiftUI."}]},"doc://FactoryKit/documentation/FactoryKit/Injected":{"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Injected","url":"\/documentation\/factorykit\/injected","title":"Injected","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"Injected"}],"kind":"symbol","abstract":[{"type":"text","text":"Convenience property wrapper takes a factory and resolves an instance of the desired type."}],"type":"topic","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Injected"}]},"doc://FactoryKit/documentation/FactoryKit/Contexts":{"title":"Contexts","kind":"article","abstract":[{"type":"text","text":"Changing injection results under special circumstances."}],"type":"topic","url":"\/documentation\/factorykit\/contexts","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Contexts","role":"article"}}}
