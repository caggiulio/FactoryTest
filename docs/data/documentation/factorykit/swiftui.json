{"abstract":[{"type":"text","text":"Defining and using dependencies in SwiftUI."}],"kind":"article","metadata":{"modules":[{"name":"FactoryKit"}],"role":"article","title":"SwiftUI","roleHeading":"Article"},"sections":[],"seeAlsoSections":[{"anchor":"Development-and-Testing","title":"Development and Testing","generated":true,"identifiers":["doc:\/\/FactoryKit\/documentation\/FactoryKit\/Previews","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Testing","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Contexts","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Debugging","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Chains"]}],"primaryContentSections":[{"kind":"content","content":[{"text":"Overview","anchor":"Overview","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Factory can make SwiftUI easier to use when we’re using view models or services and those entities depend on internal dependencies. Let’s take a look.","type":"text"}]},{"text":"StateObjects","anchor":"StateObjects","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Factory can be used to assign a fully constructed dependency to a ","type":"text"},{"code":"StateObject","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"ObservedObject","type":"codeVoice"},{"text":".","type":"text"}]},{"code":["\/\/ the view model","class ContentViewModel: ObservableObject {","    @Injected(\\.myService) private var service","    @Published var results: Results","    func load() async {","        results = await service.load()","    }","}","","\/\/ the factory","extension Container {","    var contentViewModel: Factory<ContentViewModel> {","        self { ContentViewModel() }","    }","}","","\/\/ the view","struct ContentView: View {","    @StateObject var viewModel = Container.shared.contentViewModel()","    var body: some View {","        ...","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Keep in mind that if you assign to an ","type":"text"},{"type":"codeVoice","code":"ObservedObject"},{"text":" your Factory is responsible for managing the object’s lifecycle (see the section on Scopes).","type":"text"}]},{"text":"InjectedObject","anchor":"InjectedObject","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then again, if your view model is coming from Factory, we can bypass the shared container code and just use the "},{"type":"codeVoice","code":"InjectedObject"},{"type":"text","text":" property wrapper."}]},{"code":["\/\/ the view","struct ContentView: View {","    @InjectedObject(\\.contentViewModel) private var viewModel","    var body: some View {","        ...","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"InjectedObject uses ","type":"text"},{"type":"codeVoice","code":"StateObject"},{"text":" under the hood, so ownership is implied.","type":"text"}]},{"text":"ViewModel Dependencies","anchor":"ViewModel-Dependencies","level":2,"type":"heading"},{"inlineContent":[{"type":"text","text":"Note that our view model used the "},{"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Injected","type":"reference","isActive":true},{"type":"text","text":" property wrapper to obtain its dependency."}],"type":"paragraph"},{"code":["class ContentViewModel: ObservableObject {","    @Injected(\\.myService) private var service","    ...","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"As such, there’s no particular reason to obtain the view model from Factory since the view model knows what it needs and it’s perfectly capable of managing things for itself."}],"type":"paragraph"},{"code":["struct ContentView: View {","    @StateObject private var viewModel = ContentViewModel()","    var body: some View {","        ...","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"That would be different if, for example, our view model wanted its dependencies passed via an initializer."}],"type":"paragraph"},{"code":["class ContentViewModel: ObservableObject {","    private let service: MyServiceType","    init(service: MyServiceType)","        self.service = service","    }","    ...","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"In which case we might indeed want our container to provide a fully initialized object."}],"type":"paragraph"},{"code":["extension Container {","    var contentViewModel: Factory<ContentViewModel> {","        self { ContentViewModel(service: myService()) }","    }","    var myService: Factory<MyServiceType> {","        self { MyService() }","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"And back to ","type":"text"},{"code":"InjectedObject","type":"codeVoice"},{"text":" we go.","type":"text"}],"type":"paragraph"},{"level":2,"anchor":"Observation","type":"heading","text":"Observation"},{"inlineContent":[{"text":"Apple added support for a new framework to iOS 17–Observation. Observation promises better efficiency and fewer view updates when used across multiple views. So how do we use it?","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Here’s our previous example, updated for Observation.","type":"text"}]},{"type":"codeListing","code":["@Observable","class ContentViewModel {","    @ObservationIgnored @Injected(\\.myService) private var service","    var results: Results","    func load() async {","        results = await service.load()","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We replaced the "},{"type":"codeVoice","code":"ObservableObject"},{"type":"text","text":" protocol conformance with the "},{"type":"codeVoice","code":"@Observable"},{"type":"text","text":" macro and removed the "},{"type":"codeVoice","code":"@Published"},{"type":"text","text":" attribute from results."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note, however, that we needed to add "},{"type":"codeVoice","code":"@ObservationIgnored"},{"type":"text","text":" to our "},{"type":"codeVoice","code":"Injected"},{"type":"text","text":" service property wrapper. It’s a private value and doesn’t need to be visible outside of our view model."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s the view."}]},{"type":"codeListing","code":["struct ContentView: View {","    @InjectedObservable(\\.contentViewModel) var viewModel","    var body: some View {","        ...","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Instead of "},{"type":"codeVoice","code":"InjectedObject"},{"type":"text","text":" we use "},{"type":"codeVoice","code":"InjectedObservable"},{"type":"text","text":", a new property wrapper that understands how to work with the Observable protocol established by Observation."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"InjectedObservable uses "},{"type":"codeVoice","code":"State"},{"type":"text","text":" under the hood and, like "},{"type":"codeVoice","code":"InjectedObject"},{"type":"text","text":", owns the instance in question."}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"One should also note that InjectedObject “thunks” its parameter and only one instance of the injected view model will be created for the lifetime of the view.","type":"text"}],"type":"emphasis"}]},{"type":"heading","level":2,"text":"Coping With @MainActor","anchor":"Coping-With-MainActor"},{"type":"paragraph","inlineContent":[{"text":"One last thing missing from our SwiftUI sample code is @MainActor, that Swift Concurrency attribute used to ensure all view updates occur on the main thread.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Let’s update our view model and see what else needs to change.","type":"text"}]},{"type":"codeListing","code":["\/\/ the view model","@MainActor","@Observable","class ContentViewModel {","    @ObservationIgnored @Injected(\\.myService) private var service","    var results: Results","    func load() async {","        results = await service.load()","    }","}","","\/\/ the factory","extension Container {","    @MainActor","    var contentViewModel: Factory<ContentViewModel> {","        self { ContentViewModel() }","    }","}","","\/\/ the view","struct ContentView: View {","    @InjectedObservable(\\.contentViewModel) var viewModel","    var body: some View {","        ...","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"As you can see adding ","type":"text"},{"code":"@MainActor","type":"codeVoice"},{"text":" to our view model also required us to annotate the Factory accordingly, adding it to both the definition ","type":"text"},{"inlineContent":[{"type":"text","text":"and"}],"type":"emphasis"},{"text":" to the factory closure.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"While we’d never do it in this case, adding actor isolation to the base factory also means that we’d need to do so again should we ever want to register a new factory."}]},{"type":"codeListing","code":["Container.shared.contentViewModel.register { ","    ContentViewModel()","}",""],"syntax":"swift"}]}],"hierarchy":{"paths":[["doc:\/\/FactoryKit\/documentation\/FactoryKit"]]},"schemaVersion":{"major":0,"patch":0,"minor":3},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/factorykit\/swiftui"]}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/SwiftUI"},"references":{"doc://FactoryKit/documentation/FactoryKit":{"abstract":[{"text":"A modern approach to Container-Based Dependency Injection for Swift and SwiftUI.","type":"text"}],"url":"\/documentation\/factorykit","role":"collection","type":"topic","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit","kind":"symbol","title":"FactoryKit"},"doc://FactoryKit/documentation/FactoryKit/Testing":{"url":"\/documentation\/factorykit\/testing","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Testing","abstract":[{"text":"Using Factory for Unit and UI Testing.","type":"text"}],"type":"topic","role":"article","title":"Testing","kind":"article"},"doc://FactoryKit/documentation/FactoryKit/Injected":{"abstract":[{"text":"Convenience property wrapper takes a factory and resolves an instance of the desired type.","type":"text"}],"type":"topic","kind":"symbol","title":"Injected","navigatorTitle":[{"kind":"identifier","text":"Injected"}],"url":"\/documentation\/factorykit\/injected","role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Injected"}],"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Injected"},"doc://FactoryKit/documentation/FactoryKit/Debugging":{"url":"\/documentation\/factorykit\/debugging","type":"topic","abstract":[{"type":"text","text":"Additional support for debugging resolution cycles, dependency chains and other issue."}],"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Debugging","role":"article","title":"Debugging","kind":"article"},"doc://FactoryKit/documentation/FactoryKit/Previews":{"type":"topic","url":"\/documentation\/factorykit\/previews","title":"SwiftUI Previews","kind":"article","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Previews","abstract":[{"type":"text","text":"Mocking dependencies for SwiftUI Previews."}],"role":"article"},"doc://FactoryKit/documentation/FactoryKit/Chains":{"type":"topic","url":"\/documentation\/factorykit\/chains","title":"Circular Dependency Chains","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Chains","kind":"article","abstract":[{"type":"text","text":"Detecting and solving Circular Dependency Chains."}],"role":"article"},"doc://FactoryKit/documentation/FactoryKit/Contexts":{"type":"topic","url":"\/documentation\/factorykit\/contexts","title":"Contexts","kind":"article","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Contexts","abstract":[{"text":"Changing injection results under special circumstances.","type":"text"}],"role":"article"}}}