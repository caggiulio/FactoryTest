{"abstract":[{"type":"text","text":"Detecting and solving Circular Dependency Chains."}],"kind":"article","metadata":{"modules":[{"name":"FactoryKit"}],"roleHeading":"Article","title":"Circular Dependency Chains","role":"article"},"sections":[],"seeAlsoSections":[{"anchor":"Development-and-Testing","title":"Development and Testing","identifiers":["doc:\/\/FactoryKit\/documentation\/FactoryKit\/SwiftUI","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Previews","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Testing","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Contexts","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Debugging"],"generated":true}],"primaryContentSections":[{"kind":"content","content":[{"level":2,"type":"heading","anchor":"Circular-Dependency-Chain-Detection","text":"Circular Dependency Chain Detection"},{"type":"paragraph","inlineContent":[{"type":"text","text":"What’s a circular dependency? Let’s say that A needs B to be constructed, and B needs a C. But what happens if C needs an A?"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Examine the following class definitions."}]},{"type":"codeListing","code":["class CircularA {","    @Injected(\\.circularB) var circularB","}","","class CircularB {","    @Injected(\\.circularC) var circularC","}","","class CircularC {","    @Injected(\\.circularA) var circularA","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Attempting make an instance of "},{"type":"codeVoice","code":"CircularA"},{"type":"text","text":" is going to result in an infinite loop."}]},{"type":"paragraph","inlineContent":[{"text":"Why? Well, A’s injected property wrapper needs a B in to construct an A. Okay, fine. Let’s make one. But B’s wrapper needs a C, which can’t be made without injecting an A, which once more needs a B… and so on. Ad infinitum.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"This is a circular dependency chain.","type":"text"}]},{"level":2,"type":"heading","anchor":"Resolution","text":"Resolution"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Unfortunately, by the time this code is compiled and run it’s too late to break the cycle. We’ve effectively coded an infinite loop into our program."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"All Factory can do in this case is die gracefully and in the process dump the dependency chain that indicates where the problem lies."}]},{"type":"codeListing","code":["2022-12-23 14:57:23.512032-0600 FactoryDemo[47546:6946786] Factory\/Factory.swift:393: ","FACTORY: Circular dependency on Container.recursiveA"],"syntax":null},{"type":"paragraph","inlineContent":[{"text":"With the above information in hand we could start walking recursiveA’s dependency tree to find the problem… but Factory provides an easier way. Just turn on trace prior to creating recursiveA.","type":"text"}]},{"type":"codeListing","code":["Container.shared.manager.trace.toggle()","let a = Container.shared.recursiveA()"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"With the trace log in hand, the cycle becomes obvious.","type":"text"}]},{"type":"codeListing","code":["0: FactoryKit.Container.circularA<FactoryDemo.CircularA>","1:     FactoryKit.Container.circularB<FactoryDemo.CircularB>","2:         FactoryKit.Container.circularC<FactoryDemo.CircularC>","3:             FactoryKit.Container.circularA<FactoryDemo.CircularA>"],"syntax":null},{"type":"paragraph","inlineContent":[{"type":"text","text":"CircularC is attempting to inject an instance of CircularA, and we can see that in the code."}]},{"type":"codeListing","code":["class RecursiveC {","    @Injected(\\.recursiveA) var a: RecursiveA?","    init() {}","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"We could fix things by changing CircularC’s injection wrapper to ","type":"text"},{"code":"LazyInjected","type":"codeVoice"},{"text":" or, better yet, ","type":"text"},{"code":"WeakLazyInjected","type":"codeVoice"},{"text":" in order to avoid a retain cycle.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"But a better solution would probably entail breaking out some of the functionality from RecursiveA and creating a "},{"inlineContent":[{"type":"text","text":"third"}],"type":"emphasis"},{"type":"text","text":" object that RecursiveA "},{"inlineContent":[{"type":"text","text":"and"}],"type":"emphasis"},{"type":"text","text":" RecursiveC could both include."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Circular dependencies such as this are usually a violation of the Single Responsibility Principle, and should be avoided."}]},{"name":"Important","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Due to the overhead involved, circular dependency detection only occurs when running the application in DEBUG mode. The code is stripped out of production builds for improved performance."}]}],"style":"important"},{"type":"heading","anchor":"Disabling-CDC-Detection","text":"Disabling CDC Detection","level":2},{"type":"paragraph","inlineContent":[{"text":"Circular dependency chain detection can be disabled if desired.","type":"text"}]},{"code":["Container.shared.manager.circularDependencyTestingEnabled = false"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"This value is global to all containers.","type":"text"}]}]}],"hierarchy":{"paths":[["doc:\/\/FactoryKit\/documentation\/FactoryKit"]]},"schemaVersion":{"major":0,"patch":0,"minor":3},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/factorykit\/chains"]}],"identifier":{"url":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Chains","interfaceLanguage":"swift"},"references":{"doc://FactoryKit/documentation/FactoryKit/Previews":{"type":"topic","url":"\/documentation\/factorykit\/previews","title":"SwiftUI Previews","kind":"article","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Previews","abstract":[{"type":"text","text":"Mocking dependencies for SwiftUI Previews."}],"role":"article"},"doc://FactoryKit/documentation/FactoryKit/Testing":{"url":"\/documentation\/factorykit\/testing","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Testing","abstract":[{"text":"Using Factory for Unit and UI Testing.","type":"text"}],"type":"topic","role":"article","title":"Testing","kind":"article"},"doc://FactoryKit/documentation/FactoryKit":{"abstract":[{"text":"A modern approach to Container-Based Dependency Injection for Swift and SwiftUI.","type":"text"}],"url":"\/documentation\/factorykit","role":"collection","type":"topic","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit","kind":"symbol","title":"FactoryKit"},"doc://FactoryKit/documentation/FactoryKit/Debugging":{"url":"\/documentation\/factorykit\/debugging","type":"topic","abstract":[{"type":"text","text":"Additional support for debugging resolution cycles, dependency chains and other issue."}],"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Debugging","role":"article","title":"Debugging","kind":"article"},"doc://FactoryKit/documentation/FactoryKit/SwiftUI":{"type":"topic","url":"\/documentation\/factorykit\/swiftui","title":"SwiftUI","abstract":[{"type":"text","text":"Defining and using dependencies in SwiftUI."}],"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/SwiftUI","kind":"article","role":"article"},"doc://FactoryKit/documentation/FactoryKit/Contexts":{"type":"topic","url":"\/documentation\/factorykit\/contexts","title":"Contexts","kind":"article","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Contexts","abstract":[{"text":"Changing injection results under special circumstances.","type":"text"}],"role":"article"}}}